# Implementation Plan: Downshiftology Recipe Search

**Branch**: `005-downshiftology-recipes` | **Date**: 2026-02-24 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/005-downshiftology-recipes/spec.md`

## Summary

Add Downshiftology.com recipe search to the WhatsApp bot — Erin can say "find me a chicken dinner recipe" and get results from Downshiftology's 861-recipe catalogue via their public WordPress REST API. Results include recipe names, prep times, dietary tags, and direct links. Recipes can be imported into the Notion catalogue for meal planning. Grocery history cross-referencing shows which ingredients the family already buys.

## Technical Context

**Language/Version**: Python 3.12 (existing codebase)
**Primary Dependencies**: FastAPI, anthropic SDK (Claude Opus), httpx (Downshiftology API calls), notion-client >=2.2.0,<2.3.0
**Storage**: Downshiftology API (external, read-only), Notion Recipes + Cookbooks databases (read/write)
**Testing**: Manual validation via WhatsApp + curl
**Target Platform**: Docker Compose on NUC (Linux, amd64)
**Project Type**: Web service (existing FastAPI app)
**Performance Goals**: Search results < 15 seconds, recipe import < 20 seconds
**Constraints**: Downshiftology API max 100 results per page; no reliable dietary filtering via API taxonomy
**Scale/Scope**: 2 users, <500 messages/month, <20 recipe searches/day

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Evidence |
|-----------|--------|----------|
| I. Integration Over Building | PASS | Uses Downshiftology's existing API — no recipe database built, no scraping engine |
| II. Mobile-First Access | PASS | All interactions via WhatsApp on iPhone — search, browse, import, all conversational |
| III. Simplicity & Low Friction | PASS | "Find me a chicken dinner" → numbered list → "save number 2" — 2 messages max |
| IV. Structured Output | PASS | Search results as numbered lists with name, time, tags. Import confirmation as structured details |
| V. Incremental Value | PASS | US1 (search) works standalone with links. US2 (import) adds catalogue integration. US3 (grocery matching) adds intelligence. Each independently useful |

No violations. All principles satisfied.

## Project Structure

### Documentation (this feature)

```text
specs/005-downshiftology-recipes/
├── plan.md              # This file
├── research.md          # Downshiftology API research + architecture decisions
├── data-model.md        # Entities, taxonomy IDs, tag mapping
├── quickstart.md        # Setup and validation guide
├── contracts/
│   └── recipe-tools.md  # Tool definitions for Claude
├── checklists/
│   └── requirements.md  # Spec quality checklist
└── tasks.md             # Task breakdown (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
src/
├── tools/
│   ├── downshiftology.py  # NEW: search, import, details functions + caching
│   ├── recipes.py         # Existing: extended for grocery cross-reference
│   └── notion.py          # Existing: extended with source_url parameter
├── assistant.py           # Extended: +3 tool defs, system prompt updates
└── config.py              # No changes needed
```

**Structure Decision**: One new file (`downshiftology.py`) for the external API integration. This keeps Downshiftology-specific logic separate from the existing recipe OCR tools in `recipes.py`. Notion and assistant changes are additions to existing files.

## Key Implementation Decisions

### 1. API Strategy (R1, R2, research.md)

Use the WordPress REST API with combined filters. Claude interprets natural language into API parameters (course, cuisine, search term). The `_fields` parameter limits response size. Roundup posts filtered by `parent_post_id != 0`.

### 2. Dietary Filtering (R3, research.md)

Client-side filtering only. The API's keyword taxonomy is too fragmented for reliable dietary queries. Fetch broader results (up to 20), then filter by checking if dietary terms appear in recipe name, summary, or keyword tags.

### 3. Search Result Caching (R6, research.md)

Module-level `_last_search_results` list stores the most recent search. Enables "save number 3" and "tell me more about 2" follow-up commands without re-querying the API.

### 4. Recipe Import (R7, research.md)

Map Downshiftology API fields directly to existing Notion properties. Model "Downshiftology" as a Cookbook entry. Add `Source URL` property for deduplication and attribution.

### 5. Grocery Cross-Reference (R5, research.md)

For MVP, pass ingredient lists to Claude and let it reason about grocery history matches rather than building programmatic fuzzy matching. Claude can say "You usually buy chicken and olive oil" by cross-referencing the ingredient list with grocery history data.

## Phases

### Phase 1: Setup
- Add `Source URL` property to Notion Recipes DB (manual step)
- Update `create_recipe()` in notion.py to accept `source_url` parameter

### Phase 2: Core — Downshiftology Search (US1)
- Create `src/tools/downshiftology.py` with search function
- Static taxonomy maps (course name → ID, cuisine name → ID)
- Client-side dietary and time filtering
- Search result caching for follow-ups
- Register `search_downshiftology` and `get_downshiftology_details` tools

### Phase 3: Import (US2)
- Implement `import_downshiftology_recipe()` in downshiftology.py
- Data mapping from API to Notion properties
- Duplicate detection by Source URL
- Auto-create "Downshiftology" cookbook if needed
- Register `import_downshiftology_recipe` tool

### Phase 4: Smart Recommendations (US3)
- Extend `get_downshiftology_details` to include grocery history cross-reference
- Fetch grocery history, pass ingredient list + history to Claude for matching
- Add "X/Y ingredients on hand" and "New ingredient" annotations

### Phase 5: Polish & Deploy
- System prompt updates for recipe search interaction guidelines
- Deploy and validate all 6 test scenarios
